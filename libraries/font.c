// SPDX-License-Identifier: GPL-3.0-or-later
//
// font.c — Tiny bitmap font & text rasterizer for Vitte Light (C17, portable)
// Namespace: "font"
//
// Build:
//   cc -std=c17 -O2 -Wall -Wextra -pedantic -c font.c
//
// Summary:
//   - 5x7 monospaced bitmap font, integer scale, tight clipping.
//   - RGBA8888 blitter with alpha blending (fg alpha honored).
//   - API:
//       typedef struct { int w, h, advance, baseline; } font_info_t;
//       const font_info_t* font5x7_info(void);
//       // Return 7 rows for ASCII 'c' in low 5 bits; returns 0 on miss (all zero)
//       int  font5x7_get_rows(unsigned char c, uint8_t out_rows[7]);
//       // Measure (width x height) for null-terminated UTF-8 assumed ASCII
//       void font5x7_measure(const char* s, int scale, int* out_w, int* out_h);
//       // Draw text at (x,y) top-left into RGBA8888 buffer (stride in pixels)
//       // Transparent background. Newlines supported. Tab == 4 spaces.
//       void font5x7_draw_rgba(uint32_t* img, int W, int H, int stride,
//                              int x, int y, const char* s, uint32_t fg_rgba, int scale);
//
// Notes:
//   - Only ASCII 32..126 guaranteed. Missing glyphs render as '?'.
//   - Data table contains compact rows for common glyphs; unknowns map to '?'.
//   - Keep simple; extend table if you need more symbols.

#include <stdint.h>
#include <stddef.h>
#include <string.h>

// ---------------- Font metadata ----------------

typedef struct { int w, h, advance, baseline; } font_info_t;

static const font_info_t g_info = { 5, 7, 6, 7 }; // 1px right-side spacing

const font_info_t* font5x7_info(void) { return &g_info; }

// ---------------- 5x7 bitmap table ----------------
// Each glyph: 7 bytes (rows top→bottom). Low 5 bits are columns left→right.
// Only a curated subset defined explicitly: space, digits, A-Z, a-z, punctuation used often.
// Any missing character resolves to '?' glyph.

typedef struct { unsigned char ch; uint8_t rows[7]; } glyph_t;

#define R7(a,b,c,d,e,f,g) { (uint8_t)(a), (uint8_t)(b), (uint8_t)(c), (uint8_t)(d), (uint8_t)(e), (uint8_t)(f), (uint8_t)(g) }

// Bit helper macro: write row as b4..b0 columns; example 0b10101 → 0x15
// Below patterns are classic 5x7 forms.

static const glyph_t g_tbl[] = {
    // Space and punctuation minimal
    { ' ', R7(0x00,0x00,0x00,0x00,0x00,0x00,0x00) },
    { '!', R7(0x04,0x04,0x04,0x04,0x00,0x00,0x04) },
    { '"', R7(0x0A,0x0A,0x0A,0x00,0x00,0x00,0x00) },
    { '#', R7(0x0A,0x1F,0x0A,0x0A,0x1F,0x0A,0x00) },
    { '$', R7(0x04,0x0F,0x14,0x0E,0x05,0x1E,0x04) },
    { '%', R7(0x18,0x19,0x02,0x04,0x08,0x13,0x03) },
    { '&', R7(0x0C,0x12,0x14,0x08,0x15,0x12,0x0D) },
    { '\'',R7(0x04,0x04,0x02,0x00,0x00,0x00,0x00) },
    { '(', R7(0x02,0x04,0x08,0x08,0x08,0x04,0x02) },
    { ')', R7(0x08,0x04,0x02,0x02,0x02,0x04,0x08) },
    { '*', R7(0x00,0x04,0x15,0x0E,0x15,0x04,0x00) },
    { '+', R7(0x00,0x04,0x04,0x1F,0x04,0x04,0x00) },
    { ',', R7(0x00,0x00,0x00,0x00,0x06,0x06,0x02) },
    { '-', R7(0x00,0x00,0x00,0x1F,0x00,0x00,0x00) },
    { '.', R7(0x00,0x00,0x00,0x00,0x06,0x06,0x00) },
    { '/', R7(0x01,0x01,0x02,0x04,0x08,0x10,0x10) },

    // Digits 0-9
    { '0', R7(0x0E,0x11,0x13,0x15,0x19,0x11,0x0E) },
    { '1', R7(0x04,0x0C,0x04,0x04,0x04,0x04,0x0E) },
    { '2', R7(0x0E,0x11,0x01,0x06,0x08,0x10,0x1F) },
    { '3', R7(0x1F,0x02,0x04,0x02,0x01,0x11,0x0E) },
    { '4', R7(0x02,0x06,0x0A,0x12,0x1F,0x02,0x02) },
    { '5', R7(0x1F,0x10,0x1E,0x01,0x01,0x11,0x0E) },
    { '6', R7(0x06,0x08,0x10,0x1E,0x11,0x11,0x0E) },
    { '7', R7(0x1F,0x01,0x02,0x04,0x08,0x08,0x08) },
    { '8', R7(0x0E,0x11,0x11,0x0E,0x11,0x11,0x0E) },
    { '9', R7(0x0E,0x11,0x11,0x0F,0x01,0x02,0x0C) },

    { ':', R7(0x00,0x06,0x06,0x00,0x06,0x06,0x00) },
    { ';', R7(0x00,0x06,0x06,0x00,0x06,0x06,0x02) },
    { '<', R7(0x02,0x04,0x08,0x10,0x08,0x04,0x02) },
    { '=', R7(0x00,0x00,0x1F,0x00,0x1F,0x00,0x00) },
    { '>', R7(0x08,0x04,0x02,0x01,0x02,0x04,0x08) },
    { '?', R7(0x0E,0x11,0x01,0x02,0x04,0x00,0x04) },

    { '@', R7(0x0E,0x11,0x01,0x0D,0x15,0x15,0x0E) },

    // Uppercase A-Z
    { 'A', R7(0x0E,0x11,0x11,0x1F,0x11,0x11,0x11) },
    { 'B', R7(0x1E,0x11,0x11,0x1E,0x11,0x11,0x1E) },
    { 'C', R7(0x0E,0x11,0x10,0x10,0x10,0x11,0x0E) },
    { 'D', R7(0x1C,0x12,0x11,0x11,0x11,0x12,0x1C) },
    { 'E', R7(0x1F,0x10,0x10,0x1E,0x10,0x10,0x1F) },
    { 'F', R7(0x1F,0x10,0x10,0x1E,0x10,0x10,0x10) },
    { 'G', R7(0x0E,0x11,0x10,0x17,0x11,0x11,0x0E) },
    { 'H', R7(0x11,0x11,0x11,0x1F,0x11,0x11,0x11) },
    { 'I', R7(0x0E,0x04,0x04,0x04,0x04,0x04,0x0E) },
    { 'J', R7(0x07,0x02,0x02,0x02,0x12,0x12,0x0C) },
    { 'K', R7(0x11,0x12,0x14,0x18,0x14,0x12,0x11) },
    { 'L', R7(0x10,0x10,0x10,0x10,0x10,0x10,0x1F) },
    { 'M', R7(0x11,0x1B,0x15,0x15,0x11,0x11,0x11) },
    { 'N', R7(0x11,0x19,0x15,0x13,0x11,0x11,0x11) },
    { 'O', R7(0x0E,0x11,0x11,0x11,0x11,0x11,0x0E) },
    { 'P', R7(0x1E,0x11,0x11,0x1E,0x10,0x10,0x10) },
    { 'Q', R7(0x0E,0x11,0x11,0x11,0x15,0x12,0x0D) },
    { 'R', R7(0x1E,0x11,0x11,0x1E,0x14,0x12,0x11) },
    { 'S', R7(0x0F,0x10,0x10,0x0E,0x01,0x01,0x1E) },
    { 'T', R7(0x1F,0x04,0x04,0x04,0x04,0x04,0x04) },
    { 'U', R7(0x11,0x11,0x11,0x11,0x11,0x11,0x0E) },
    { 'V', R7(0x11,0x11,0x11,0x11,0x11,0x0A,0x04) },
    { 'W', R7(0x11,0x11,0x11,0x15,0x15,0x1B,0x11) },
    { 'X', R7(0x11,0x11,0x0A,0x04,0x0A,0x11,0x11) },
    { 'Y', R7(0x11,0x11,0x0A,0x04,0x04,0x04,0x04) },
    { 'Z', R7(0x1F,0x01,0x02,0x04,0x08,0x10,0x1F) },

    { '[', R7(0x0E,0x08,0x08,0x08,0x08,0x08,0x0E) },
    { '\\',R7(0x10,0x10,0x08,0x04,0x02,0x01,0x01) },
    { ']', R7(0x0E,0x02,0x02,0x02,0x02,0x02,0x0E) },
    { '^', R7(0x04,0x0A,0x11,0x00,0x00,0x00,0x00) },
    { '_', R7(0x00,0x00,0x00,0x00,0x00,0x00,0x1F) },
    { '`', R7(0x08,0x04,0x02,0x00,0x00,0x00,0x00) },

    // Lowercase a-z
    { 'a', R7(0x00,0x00,0x0E,0x01,0x0F,0x11,0x0F) },
    { 'b', R7(0x10,0x10,0x1E,0x11,0x11,0x11,0x1E) },
    { 'c', R7(0x00,0x00,0x0E,0x11,0x10,0x11,0x0E) },
    { 'd', R7(0x01,0x01,0x0F,0x11,0x11,0x11,0x0F) },
    { 'e', R7(0x00,0x00,0x0E,0x11,0x1F,0x10,0x0E) },
    { 'f', R7(0x06,0x08,0x1E,0x08,0x08,0x08,0x08) },
    { 'g', R7(0x00,0x00,0x0F,0x11,0x11,0x0F,0x01) },
    { 'h', R7(0x10,0x10,0x1E,0x11,0x11,0x11,0x11) },
    { 'i', R7(0x04,0x00,0x0C,0x04,0x04,0x04,0x0E) },
    { 'j', R7(0x02,0x00,0x06,0x02,0x02,0x12,0x0C) },
    { 'k', R7(0x10,0x10,0x12,0x14,0x18,0x14,0x12) },
    { 'l', R7(0x0C,0x04,0x04,0x04,0x04,0x04,0x0E) },
    { 'm', R7(0x00,0x00,0x1A,0x15,0x15,0x15,0x15) },
    { 'n', R7(0x00,0x00,0x1E,0x11,0x11,0x11,0x11) },
    { 'o', R7(0x00,0x00,0x0E,0x11,0x11,0x11,0x0E) },
    { 'p', R7(0x00,0x00,0x1E,0x11,0x11,0x1E,0x10) },
    { 'q', R7(0x00,0x00,0x0F,0x11,0x11,0x0F,0x01) },
    { 'r', R7(0x00,0x00,0x16,0x18,0x10,0x10,0x10) },
    { 's', R7(0x00,0x00,0x0F,0x10,0x0E,0x01,0x1E) },
    { 't', R7(0x08,0x08,0x1E,0x08,0x08,0x09,0x06) },
    { 'u', R7(0x00,0x00,0x11,0x11,0x11,0x11,0x0F) },
    { 'v', R7(0x00,0x00,0x11,0x11,0x11,0x0A,0x04) },
    { 'w', R7(0x00,0x00,0x11,0x11,0x15,0x15,0x0A) },
    { 'x', R7(0x00,0x00,0x11,0x0A,0x04,0x0A,0x11) },
    { 'y', R7(0x00,0x00,0x11,0x11,0x11,0x0F,0x01) },
    { 'z', R7(0x00,0x00,0x1F,0x02,0x04,0x08,0x1F) },

    { '{', R7(0x02,0x04,0x04,0x08,0x04,0x04,0x02) },
    { '|', R7(0x04,0x04,0x04,0x00,0x04,0x04,0x04) },
    { '}', R7(0x08,0x04,0x04,0x02,0x04,0x04,0x08) },
    { '~', R7(0x00,0x00,0x0A,0x15,0x00,0x00,0x00) },
};

static const uint8_t* find_rows(unsigned char c) {
    // direct lookup over small table
    for (size_t i=0; i < sizeof(g_tbl)/sizeof(g_tbl[0]); ++i)
        if (g_tbl[i].ch == c) return g_tbl[i].rows;
    // fallback to '?'
    for (size_t i=0; i < sizeof(g_tbl)/sizeof(g_tbl[0]); ++i)
        if (g_tbl[i].ch == '?') return g_tbl[i].rows;
    return NULL;
}

int font5x7_get_rows(unsigned char c, uint8_t out_rows[7]) {
    const uint8_t* r = find_rows(c);
    if (!r) return 0;
    for (int i=0;i<7;i++) out_rows[i] = r[i] & 0x1F;
    return 1;
}

// ---------------- Measure ----------------

void font5x7_measure(const char* s, int scale, int* out_w, int* out_h) {
    if (scale < 1) scale = 1;
    int w = 0, h = g_info.h * scale;
    int line_w = 0;
    for (const unsigned char* p=(const unsigned char*)s; *p; ++p) {
        unsigned char c = *p;
        if (c == '\n') { if (line_w > w) w = line_w; line_w = 0; h += g_info.h * scale + scale; continue; }
        if (c == '\t') { line_w += g_info.advance * 4 * scale; continue; }
        line_w += g_info.advance * scale;
    }
    if (line_w > w) w = line_w;
    if (out_w) *out_w = w;
    if (out_h) *out_h = h;
}

// ---------------- Blitting ----------------

static inline uint32_t blend_over(uint32_t dst, uint32_t src) {
    // RGBA8888, straight alpha
    uint32_t sa = (src >> 24) & 0xFF;
    if (sa == 255) return src;
    if (sa == 0)   return dst;
    uint32_t da = (dst >> 24) & 0xFF;

    uint32_t sr = (src >> 16) & 0xFF, sg = (src >> 8) & 0xFF, sb = (src) & 0xFF;
    uint32_t dr = (dst >> 16) & 0xFF, dg = (dst >> 8) & 0xFF, db = (dst) & 0xFF;

    uint32_t outA = sa + ((da * (255 - sa)) / 255);
    uint32_t outR = (sr * sa + dr * (255 - sa)) / 255;
    uint32_t outG = (sg * sa + dg * (255 - sa)) / 255;
    uint32_t outB = (sb * sa + db * (255 - sa)) / 255;
    return (outA << 24) | (outR << 16) | (outG << 8) | outB;
}

static void draw_glyph(uint32_t* img, int W, int H, int stride,
                       int x, int y, const uint8_t rows[7],
                       uint32_t fg, int scale)
{
    if (scale < 1) scale = 1;
    for (int ry = 0; ry < 7; ++ry) {
        uint8_t bits = rows[ry];
        for (int rx = 0; rx < 5; ++rx) {
            if (bits & (1u << (4 - rx))) {
                int px0 = x + rx * scale;
                int py0 = y + ry * scale;
                // scaled solid block
                for (int dy = 0; dy < scale; ++dy) {
                    int py = py0 + dy;
                    if ((unsigned)py >= (unsigned)H) continue;
                    uint32_t* rowp = img + (size_t)py * (size_t)stride;
                    for (int dx = 0; dx < scale; ++dx) {
                        int px = px0 + dx;
                        if ((unsigned)px >= (unsigned)W) continue;
                        rowp[px] = blend_over(rowp[px], fg);
                    }
                }
            }
        }
    }
}

void font5x7_draw_rgba(uint32_t* img, int W, int H, int stride,
                       int x, int y, const char* s, uint32_t fg_rgba, int scale)
{
    if (!img || !s) return;
    if (stride <= 0) stride = W;
    if (scale < 1) scale = 1;

    int cx = x;
    int cy = y;
    uint8_t rows[7];

    for (const unsigned char* p=(const unsigned char*)s; *p; ++p) {
        unsigned char c = *p;
        if (c == '\n') { cx = x; cy += (g_info.h + 1) * scale; continue; }
        if (c == '\t') { cx += g_info.advance * 4 * scale; continue; }
        if (!font5x7_get_rows(c, rows)) continue;
        draw_glyph(img, W, H, stride, cx, cy, rows, fg_rgba, scale);
        cx += g_info.advance * scale;
        if (cx >= W && cy >= H) break;
    }
}

// ---------------- Optional demo ----------------
#ifdef FONT_DEMO
// Writes out.ppm with a demo string
#include <stdio.h>
#include <stdlib.h>
static void save_ppm(const char* path, const uint32_t* img, int W, int H) {
    FILE* f = fopen(path, "wb");
    if (!f) return;
    fprintf(f, "P6\n%d %d\n255\n", W, H);
    for (int y=0;y<H;y++) {
        for (int x=0;x<W;x++) {
            uint32_t c = img[y*W + x];
            unsigned char rgb[3] = { (c>>16)&255, (c>>8)&255, c&255 };
            fwrite(rgb,1,3,f);
        }
    }
    fclose(f);
}
int main(void) {
    int W=320,H=100;
    uint32_t* img = (uint32_t*)calloc((size_t)W*H, sizeof(uint32_t));
    // fill background gray
    for (int i=0;i<W*H;i++) img[i] = 0xFF202020u;
    const char* txt = "Vitte Light\nfont5x7 demo: ABC abc 0123456789";
    font5x7_draw_rgba(img, W, H, W, 10, 10, txt, 0xFFFFFFFFu, 3);
    save_ppm("out.ppm", img, W, H);
    free(img);
    return 0;
}
#endif